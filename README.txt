Короче

Что мы делаем:
    мы делаем перемещение частиц в вихре
    у нас есть плоскость
    на ней частицы
    они перемещаются по каким-то правилам
    потом мы это анализируем


Файлы:
    first_problem.py - первая подзадача
    second_problem.py - вторая подзадача
    third_problem.py - третья подзадача
    moving_vortex.py - первая с движущимся вихрем
    main.py - последняя из текущий подзадач, всё новое пишется в main.py и
    потом отпочковывается в нужный файл


Алгоритм в общих чертах:
    data - массив, который потом будет превращен в картинку
    particles - массив частиц, которые перемещаются каждую итерацию
    filenames - массив с именами всех созданных картинок
    flow_grid - матрица из третьей подзадачи
    watchlist - точки, которые сравниваем, watch_frames - на каких кадрах, wathc_coords - какие данные

    initial_distribution() - начальное распределение весов (читай - цветов)
                             частиц в зависимости от их расположения
    flow() - задаёт перемещение частиц за одну итерацию
    particles_to_data() - перемещает все частицы и записывает результат в data,
                          чтобы потом можно было создать картинку
    just_move() - просто перемещает частицы (юзать если алгоритм работает слишком долго)

    for i in range(-size, size*2) - генерируем частицы, записываем в particles
    for k in range(frame_number) - делаем итерации - главная часть кода:
        обнуляем data
        добавляем к filenames имя картинки, которую мы сейчас сделаем
        particles_to_data()
        делаем картинку с помощью матплотлиба

    записываем в файл координаты наблюдаемых точек для сравнения

    создаём из картинок гифку
    (опционально)создаём последнюю картинку и выводим на экран


Параметры:
    size - размер картинки в пискелях
    frame_number - количество итераций
    (можно не трогать)scale - масштабирование
    (можно не трогать)spread_rad - радиус интерполяции веса пикселя
    particle_density = n - будет генерироваться одна частица в квадрате nxn пикселей
    (можно не трогать)generate_threshold - условия генерации новых точек, чтобы не было дыр
    vortex_pivot - начальное положение центра вихря


Подзадачи:
    первая - во flow():
            dxdt = 0.05 * (-Vt_r * y / r)
            dydt = 0.05 * (Vt_r * x / r)
    вторая - во flow():
            dxdt = 0.05 * (-Vt_r * sign(x) * math.sin(theta))
            dydt = 0.05 * (Vt_r * sign(x) * math.cos(theta))
    третья - делаем матрицу, в неё записываем скорость частиц в каждой точке поля
            потом вместо вызова flow() берём значение из матрицы
            если точка не попала в узел - интерполируем через ближайщие узлы

    перемещение - перемещаем каждую итерацию vortex_pivot, в flow() прибавляем его в x, y

    сравнение результатов - сравниваем координаты точек разных методов через одинаковое
            количество итераций (допилить какое-нибудь автоматическое сравнение)

    сделать Рунге-Кутту
    доделать 3 подзадачу
